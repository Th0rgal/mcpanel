#!/bin/bash
#
# mc-wrapper-socat - Session wrapper using socat for multi-client support
#
# This version uses socat for Unix socket handling, allowing:
#   - Multiple simultaneous client connections
#   - Proper PTY allocation
#   - Clean disconnect/reconnect
#
# Dependencies: socat, script (from util-linux)
#
# Usage:
#   mc-wrapper-socat start <server-dir> [java-args...]
#   mc-wrapper-socat attach <server-dir>
#   mc-wrapper-socat send <server-dir> <command>
#   mc-wrapper-socat status <server-dir>
#   mc-wrapper-socat stop <server-dir>
#   mc-wrapper-socat log <server-dir> [lines]
#

set -euo pipefail

# Configuration
SCROLLBACK_LINES="${MC_WRAPPER_SCROLLBACK:-10000}"
RUNTIME_DIR="${MC_WRAPPER_RUNTIME_DIR:-/tmp/mc-wrapper}"
LOG_DIR="${MC_WRAPPER_LOG_DIR:-/var/log/mc-wrapper}"

# Derive paths from server directory
get_paths() {
    local server_dir="$1"
    local safe_id
    safe_id=$(echo "$server_dir" | md5sum | cut -c1-16)

    SOCKET_PATH="${RUNTIME_DIR}/${safe_id}.sock"
    INPUT_SOCKET="${RUNTIME_DIR}/${safe_id}.input.sock"
    PID_FILE="${RUNTIME_DIR}/${safe_id}.pid"
    LOG_FILE="${LOG_DIR}/${safe_id}.log"
    SERVER_NAME=$(basename "$server_dir")
}

ensure_dirs() {
    mkdir -p "$RUNTIME_DIR" "$LOG_DIR"
    chmod 700 "$RUNTIME_DIR"
}

is_running() {
    local server_dir="$1"
    get_paths "$server_dir"

    if [[ -f "$PID_FILE" ]]; then
        local pid
        pid=$(cat "$PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            return 0
        fi
    fi
    return 1
}

# Check for dependencies
check_deps() {
    local missing=()
    command -v socat >/dev/null || missing+=("socat")

    if (( ${#missing[@]} > 0 )); then
        echo "Missing dependencies: ${missing[*]}"
        echo "Install with: apt install ${missing[*]}"
        exit 1
    fi
}

do_start() {
    local server_dir="$1"
    shift

    check_deps
    get_paths "$server_dir"
    ensure_dirs

    if is_running "$server_dir"; then
        echo "Server is already running (PID: $(cat "$PID_FILE"))"
        exit 1
    fi

    # Clean up stale files
    rm -f "$SOCKET_PATH" "$INPUT_SOCKET" "$PID_FILE"

    cd "$server_dir"

    # Find server JAR
    local jar_file
    jar_file=$(find . -maxdepth 1 -name "*.jar" -type f | head -1)

    if [[ -z "$jar_file" ]]; then
        echo "No .jar file found in $server_dir"
        exit 1
    fi

    # Default Java arguments
    local java_args=("$@")
    if [[ ${#java_args[@]} -eq 0 ]]; then
        java_args=("-Xms2G" "-Xmx4G" "-jar" "$jar_file" "--nogui")
    fi

    # Initialize log
    : > "$LOG_FILE"

    echo "Starting $SERVER_NAME..."
    echo "  Directory: $server_dir"
    echo "  Socket: $SOCKET_PATH"
    echo "  Log: $LOG_FILE"

    # Start daemon
    nohup bash -c "
        set -euo pipefail

        export TERM=xterm-256color
        export COLORTERM=truecolor

        cleanup() {
            rm -f '$SOCKET_PATH' '$INPUT_SOCKET' '$PID_FILE'
        }
        trap cleanup EXIT

        echo \$\$ > '$PID_FILE'

        # Create a PTY for the Java process using script
        # Output goes to both log file and socket clients
        script -qfc 'java -Dnet.kyori.ansi.colorLevel=truecolor ${java_args[*]}' /dev/null 2>&1 | \
        while IFS= read -r line; do
            echo \"\$line\" >> '$LOG_FILE'

            # Trim log if too large (every 1000 lines)
            if (( \$(wc -l < '$LOG_FILE') > $SCROLLBACK_LINES * 2 )); then
                tail -n $SCROLLBACK_LINES '$LOG_FILE' > '${LOG_FILE}.tmp'
                mv '${LOG_FILE}.tmp' '$LOG_FILE'
            fi

            echo \"\$line\"
        done | socat -u - UNIX-LISTEN:'$SOCKET_PATH',fork,mode=600 &

        # Input socket - clients write here
        socat UNIX-LISTEN:'$INPUT_SOCKET',fork,mode=600 - | \
        while IFS= read -r cmd; do
            echo \"\$cmd\"
        done

        wait
    " > /dev/null 2>&1 &

    disown

    sleep 2

    if is_running "$server_dir"; then
        echo "Started successfully (PID: $(cat "$PID_FILE"))"
    else
        echo "Failed to start"
        exit 1
    fi
}

do_attach() {
    local server_dir="$1"
    get_paths "$server_dir"

    if ! is_running "$server_dir"; then
        echo "Server is not running"
        exit 1
    fi

    echo "Attaching to $SERVER_NAME (Ctrl+C to detach)..."

    # Show recent log
    if [[ -f "$LOG_FILE" ]]; then
        echo "--- Recent output ---"
        tail -n 50 "$LOG_FILE"
        echo "--- Live ---"
    fi

    trap 'echo -e "\nDetached."; exit 0' INT

    # Read from output socket in background
    socat -u UNIX-CONNECT:"$SOCKET_PATH" - &
    local reader_pid=$!

    # Send input to input socket
    while IFS= read -r line; do
        echo "$line" | socat - UNIX-CONNECT:"$INPUT_SOCKET" 2>/dev/null || true
    done

    kill $reader_pid 2>/dev/null || true
}

do_send() {
    local server_dir="$1"
    local command="$2"
    get_paths "$server_dir"

    if ! is_running "$server_dir"; then
        echo "Server is not running"
        exit 1
    fi

    echo "$command" | socat - UNIX-CONNECT:"$INPUT_SOCKET"
    echo "Sent: $command"
}

do_status() {
    local server_dir="$1"
    get_paths "$server_dir"

    if is_running "$server_dir"; then
        echo "Running (PID: $(cat "$PID_FILE"))"
        echo "Name: $SERVER_NAME"
        echo "Socket: $SOCKET_PATH"
        echo "Log: $LOG_FILE"

        if [[ -f "$LOG_FILE" ]]; then
            local lines
            lines=$(wc -l < "$LOG_FILE")
            echo "Log lines: $lines"
        fi
        exit 0
    else
        echo "Not running"
        exit 1
    fi
}

do_stop() {
    local server_dir="$1"
    get_paths "$server_dir"

    if ! is_running "$server_dir"; then
        echo "Server is not running"
        exit 1
    fi

    echo "Stopping $SERVER_NAME..."
    echo "stop" | socat - UNIX-CONNECT:"$INPUT_SOCKET" 2>/dev/null || true

    local timeout=30
    while (( timeout > 0 )) && is_running "$server_dir"; do
        sleep 1
        (( timeout-- ))
        echo -n "."
    done
    echo

    if is_running "$server_dir"; then
        echo "Force killing..."
        kill -9 "$(cat "$PID_FILE")" 2>/dev/null || true
        rm -f "$SOCKET_PATH" "$INPUT_SOCKET" "$PID_FILE"
    fi

    echo "Stopped"
}

do_log() {
    local server_dir="$1"
    local lines="${2:-100}"
    get_paths "$server_dir"

    if [[ -f "$LOG_FILE" ]]; then
        tail -n "$lines" "$LOG_FILE"
    else
        echo "No log file"
        exit 1
    fi
}

# Follow log in real-time
do_tail() {
    local server_dir="$1"
    get_paths "$server_dir"

    if ! is_running "$server_dir"; then
        echo "Server is not running"
        exit 1
    fi

    echo "Following $SERVER_NAME log (Ctrl+C to stop)..."
    socat -u UNIX-CONNECT:"$SOCKET_PATH" -
}

main() {
    if [[ $# -lt 2 ]]; then
        echo "mc-wrapper-socat - Minecraft server session wrapper"
        echo ""
        echo "Usage: mc-wrapper-socat <command> <server-dir> [args...]"
        echo ""
        echo "Commands:"
        echo "  start <dir> [java-args]   Start server with wrapper"
        echo "  attach <dir>              Interactive attach (input + output)"
        echo "  tail <dir>                Follow output only (read-only)"
        echo "  send <dir> <cmd>          Send single command"
        echo "  status <dir>              Check if running"
        echo "  stop <dir>                Graceful stop"
        echo "  log <dir> [N]             Show last N lines (default: 100)"
        echo ""
        echo "Environment:"
        echo "  MC_WRAPPER_SCROLLBACK     Max log lines (default: 10000)"
        echo "  MC_WRAPPER_RUNTIME_DIR    Socket directory (default: /tmp/mc-wrapper)"
        echo "  MC_WRAPPER_LOG_DIR        Log directory (default: /var/log/mc-wrapper)"
        exit 1
    fi

    local cmd="$1"
    local server_dir
    server_dir=$(realpath "$2")
    shift 2

    case "$cmd" in
        start)  do_start "$server_dir" "$@" ;;
        attach) do_attach "$server_dir" ;;
        tail)   do_tail "$server_dir" ;;
        send)   do_send "$server_dir" "$*" ;;
        status) do_status "$server_dir" ;;
        stop)   do_stop "$server_dir" ;;
        log)    do_log "$server_dir" "${1:-100}" ;;
        *)
            echo "Unknown command: $cmd"
            exit 1
            ;;
    esac
}

main "$@"
